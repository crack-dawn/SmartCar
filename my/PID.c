#include "PID.h"
#include "control.h"
#include "RobTask.h"
//pid ?????????
#define  Abs(x)   ((x) < 0 ? -(x) : (x))  //?????? 


//??????????
/**
 * @brief pid_speed  pid_location ??? ???1
 * @brief pid_speed2 pid_location2     ???2
 */
_pid pid_speed={0};  
_pid pid_location={0};

_pid pid_speed2={0};   
_pid pid_location2={0};

_pid pid_angle={0};

/*PID?????????*/
// 0.9-0.0016 5000 0.6    1.8-2.2
// 												8.5~7.5
// float Position_KP= 2.6,Position_KI=0.00,Position_KD=9.7;          /* ¦Ë???PID??? position for location*/
float Position_KP= 1.6,Position_KI=0.00,Position_KD=7.5;          /* ¦Ë???PID??? position for location*/



//2.6  5.2  1.3   //2.4 4.5 1.1
float Incremental_KP=2.6 ,Incremental_KI=5.2 ,Incremental_KD=1.3 ;    /* ?????PID??? increase for speed*/   
float Incremental_KP2=2.6,Incremental_KI2=5.2,Incremental_KD2=1.3;    /* ?????PID??? increase for speed*/   
// float Incremental_KP=2.6,Incremental_KI=7.2,Incremental_KD=0.6;    /* ?????PID??? increase for speed*/   



float Incremental_KP_A=2.3, Incremental_KI_A=0.02, Incremental_KD_A=2.0;		  /* ?????PID??? increase for angle*/
/**------------------------------??????-------------------------------------------**/
/*????????????? ??????????pid?? ?????¦Ë?????????¦Ë???p???§³??????i???§³*/


// /*PID?????????*/
// float Position_KP=2.0,Position_KI=0.001,Position_KD=0.6;          /* ¦Ë???PID??? position for location*/
// float Incremental_KP=1.6,Incremental_KI=5.00,Incremental_KD=0.6;    /* ?????PID??? increase for speed*/   
// float Incremental_KP_A=2.3, Incremental_KI_A=0.02, Incremental_KD_A=2.;		  /* ?????PID??? increase for angle*/
// /**------------------------------??????-------------------------------------------**/
// /*????????????? ??????????pid?? ?????¦Ë?????????¦Ë???p???§³??????i???§³*/


/**
 * @brief 
 * 
 * @param Lout ¦Ë??????
 * @param Lerr ¦Ë?????
 * @param minV ??§³?speed
 * @param maxV ????speed
 * @return float 
 */
float Limit_Amplitude(float Lout, float Lerr,float minV, float maxV)
{
		// float distance = Abs(Lerr);
		Lout = 0.1*Lout;
		if( Abs(Lout) > maxV) // too more
		{
			return (Lout>0)?(maxV):(-maxV);
		}
		else if( Abs(Lout) < minV ) // too min
		{
			return (Lout>0)?(minV):(-minV);
		}
		else // mormal
		{
			return Lout;
		}
}





void Top_PID_Control_CallBack_TIM6(TIM_HandleTypeDef *htim)
{
	if (htim->Instance == TIM6)  //TIM6 20 ms kernel
	{
		#if(Motor_REDUCE== 30)
			pid_speed2.actual_val   =  +(short)TIM3 -> CNT;   	//TIM3   PC6  PC7  E1 ??????| PE9   pwm1 | AN1 AN2| pid_speed2  ???   M1 
			pid_speed.actual_val  	=  -(short)TIM4 -> CNT;   	//TIM4   PD12 PD13 E2 ??????| PE11  pwm2 | BN1 BN2| pid_speed	???   M2
		#endif // 0

		#if(Motor_REDUCE== 49)
			pid_speed.actual_val  	=  +(short)(TIM4 -> CNT);   	//TIM4   PD12 PD13 E2 ??????| PE11  pwm2 | BN1 BN2| pid_speed	???   M2
			pid_speed2.actual_val   =  -(short)(TIM3 -> CNT);   	//TIM3   PC6  PC7  E1 ??????| PE9   pwm1 | AN1 AN2| pid_speed2  ???   M1 
		#endif // 0


		TIM4 -> CNT=0; 
		TIM3 -> CNT=0; 
		
		pid_location2.actual_val  += pid_speed2.actual_val; 
		pid_location.actual_val   += pid_speed.actual_val; 

		pid_angle.actual_val = RxData.angle; 
		

		if(pid_angle.param5 == PIDparam5_Angle_Control && pid_location.target_val ==pid_location2.target_val  )
		{  
			if ((Abs(pid_location2.err) < Err_disance*5 )|| Abs(pid_location.err) < Err_disance*5 )
			{
				pid_speed.out = pid_speed2.out; 
			}
		}
		PID_Calculate_Updata(&pid_location,  &pid_speed, &pid_angle);
		PID_Calculate_Updata(&pid_location2, &pid_speed2, &pid_angle);
		
		Set_Pwm(pid_speed2.out,pid_speed.out);	 //   pwm1    pwm2
	}
}






float Angle_adjust(float angle)
{
 
	float AbsAngle = Abs(angle)*100;
	if ( AbsAngle > 35 && AbsAngle < 80 )
	{
		return Limit(angle+angle+angle+angle,3.5);
	}
	else if ( AbsAngle > 80 && AbsAngle < 120 )
	{
		return Limit(angle+angle+angle+angle, 4.8);
	}
	else if ( AbsAngle > 120 &&  AbsAngle < 180)
	{
		return Limit(angle+angle+angle+angle, 6.5);
	}
	else if ( AbsAngle > 180 &&  AbsAngle < 240)
	{
		return Limit(angle+angle+angle+angle, 7.7);
	}
	else if (  AbsAngle >= 300)
	{
		return Limit(angle+angle ,8.8);
	}
	else
	{
		return 0;
	}
	
}

/**
 * @brief ??????????PID???? ????????????????||?????????????????????????
 * 
 * @param pid_L 
 * @param pid_V 
 * @param speed //?????????????
 */
void PID_Calculate_Updata(_pid *pid_L, _pid *pid_V, _pid *pid_A)
{
	static float adjust=0;
 
	location_pid_realize( pid_L );  
 
	pid_V->target_val= Limit_Amplitude(  pid_L->out,  pid_L->err , MinSpeed, pid_V->pre_target_val );
	


	/*????????? ???????????*/  // 
	if (pid_angle.param5 == PIDparam5_Angle_Control)
	{	
		adjust = Angle_adjust(pid_angle.actual_val);
	
		if (pid_V->param1 == PIDparam1_M2_Left)
		{
			pid_V->target_val += adjust;
			// if (pid_angle.actual_val > 0 )
			// {
			// 	pid_V->target_val -= 0.8;
			// }
		}	
		else if (pid_V->param1 == PIDparam1_M1_Right)
		{
			pid_V->target_val -= adjust;			
		}
		DebugA;
		printf("debug :%f\r\n", adjust);
	}

	/*????????????*/
	else if (pid_angle.param5 == PIDparam5_Speed_Control)
	{
		pid_V->target_val = pid_V->pre_target_val; 
	}
	
    /*?????????-----------------------*/
    Increase_pid_realize(pid_V);
    /*???????????*/			

	/*??????????*/
	PID_Param_Updata(    pid_L,  pid_V  ) ;
}

void PID_Param_Updata(_pid *pid_L, _pid *pid_V)
{
	switch (pid_angle.param5)
	{
		case PIDparam5_Angle_Control:
		case PIDparam5_Local_Control:
			if (Abs(pid_L->err) < Err_disance) /* ??????????,¦Ë?????Err?????????pid???? */
			{
				pid_L->param4 += 1;
				if (pid_L->param4 > PIDparam4_ready_master) // buffer time after action over
				{
					pid_L->param4 = 0;
					pid_L->pre_target_val = pid_L->target_val; // updata previous location, storage it for run to next position
					pid_L->param3 = PIDparam3_finish;		   // ???¦Æ???????? ???¦Ë????   ?????¦Ë??????????????§Ø???
				}
				if (Abs(pid_L->err) < _1mm_to_Encoder_)
				{
					pid_V->out = 0; // ?????????? 	ok
				}
				return;
			}break;
		case PIDparam5_Speed_Control:
			if (  Abs( pid_V->actual_val - pid_V->target_val  ) < 2 )
			{
				pid_V->param3 = PIDparam3_finish;
				return;
			}break;

		default:break;
	}
	
		pid_angle.param4 = 0 ;
		pid_angle.param3 = PIDparam3_doing;
		pid_L->param4 = 0 ;
		pid_L->param3 = PIDparam3_doing;
}

/*judge status  only by pid_location.param3 and  pid_location2.param3 , ignore pid_speed.param3*/
unsigned char PID_JudgeStatus()
{
	switch (pid_angle.param5)
	{
	default:
	case 		PIDparam5_Angle_Control:
	case 		PIDparam5_Local_Control:
		if(pid_location.param3==PIDparam3_finish  && pid_location2.param3==PIDparam3_finish  )
		{
			return PIDparam3_finish;
		}
		else if (pid_speed.pre_target_val ==pid_speed2.pre_target_val)
		{ //??¦Ë???????  ??????¦Ë??  ????????????????????????????????
			if(pid_location2.param3 == PIDparam3_finish)
				return PIDparam3_finish;
		}
		break;
	case PIDparam5_Speed_Control:
		if ( pid_speed.param3==PIDparam3_finish  && pid_speed.param3==PIDparam3_finish)
		{
			return PIDparam3_finish;
		}
		break;
	}
	return PIDparam3_doing;
}



/**************************************************************************
?????????????PID??????  ???? ?????????
??????????????????
????  ?????????????
????????????PID??? 
out+=Kp[e??k??-e(k-1)]+Ki*e(k)+Kd[e(k)-2e(k-1)+e(k-2)]
e(k)??????????? 
e(k-1)????????¦Å????  ??????? 
out???????????
**************************************************************************/
float Increase_pid_realize_angle(_pid *pid)
{
//	pid->actual_val =actual_val;//????  
//  pid->target_val =target_val;//?????  

  pid->err=pid->target_val - pid->actual_val; /*??????*/ /*???????????????????*/

  /*PID?????*/
  if (Abs(pid->err) < Err_angle)//??? P?????????
  {
			pid->out += pid->Kp * (pid->err - pid->err_last)					   /* ???????? */
						+ 0.002 * (pid->err)										   /* ??????? */
						+ pid->Kd * (pid->err - 2 * pid->err_last + pid->err_pre); /* ?????? */
  }
 
  else
  {
			pid->out += pid->Kp * (pid->err - pid->err_last)					   /* ???????? */
						+ pid->Ki * (pid->err)									   /* ??????? */
						+ pid->Kd * (pid->err - 2 * pid->err_last + pid->err_pre); /* ?????? */
  }

  /*?????*/
  pid->err_pre = pid->err_last; // ????????????
  pid->err_last = pid->err;		// ??????????

  /*?????????? PID?????????? ????????*/
  return pid->out;
}

/**************************************************************************
?????????????PID??????  ????
??????????????????
????  ??????PWM
????????????PID??? 
out+=Kp[e??k??-e(k-1)]+Ki*e(k)+Kd[e(k)-2e(k-1)+e(k-2)]
e(k)??????????? 
e(k-1)????????¦Å????  ??????? 
out???????????
**************************************************************************/
float Increase_pid_realize(_pid *pid)
{
//	pid->actual_val =actual_val;//????  
//  pid->target_val =target_val;//?????  

  pid->err=pid->target_val - pid->actual_val; /*??????*/ /*???????????????????*/

  /*PID?????*/
  if (Abs(pid->err) < Err_speed)//??? P?????????
  {
			pid->out += pid->Kp * (pid->err - pid->err_last)					   /* ???????? */
						+ 2.2 * (pid->err)										   /* ??????? */
						+ pid->Kd * (pid->err - 2 * pid->err_last + pid->err_pre); /* ?????? */
  }
 
  else
  {
			pid->out += pid->Kp * (pid->err - pid->err_last)					   /* ???????? */
						+ pid->Ki * (pid->err)									   /* ??????? */
						+ pid->Kd * (pid->err - 2 * pid->err_last + pid->err_pre); /* ?????? */
  }

  /*?????*/
  pid->err_pre = pid->err_last; // ????????????
  pid->err_last = pid->err;		// ??????????

  /*?????????? PID?????????? ????????*/
  return pid->out;
}

/**************************************************************************
?????????¦Ë???PID??????
???????????¦Ë??????¦Ë??
????  ??????????
????¦Ë??????PID??? 
pwm=Kp*e(k)+Ki*??e(k)+Kd[e??k??-e(k-1)]
e(k)??????????? 
e(k-1)????????¦Å????  
??e(k)????e(k)????????????????;????k?1,2,...,k;
pwm???????
**************************************************************************/
float location_pid_realize(_pid *pid)   
{
//    pid->actual_val =actual_val;//???? ????¦Ë??
//    pid->target_val =target_val;//????? ??????¦Ë??

		/*???????????????????*/
    pid->err= pid->target_val  -  pid->actual_val; //?????? P  ??????
  
    pid->integral += pid->err;          //  ????????? I ??????

    if(pid->integral> 500) pid->integral = 500;   /* ??????? */
    if(pid->integral<-500) pid->integral =-500;

		/*PID?????*/
	// if( Abs(pid->err) < Err_disance*4 )
	// {
	// 	pid->out =      1.6*pid->err
	// 					+pid->Ki*pid->integral
	// 					+pid->Kd*(pid->err-pid->err_last);
	// }
	// else
	{
		pid->out = pid->Kp*pid->err
			+pid->Ki*pid->integral
			+pid->Kd*(pid->err-pid->err_last);
	}
		/*?????*/
    pid->err_last=pid->err;
    
		/*?????????*/
    return pid->out;
}

/*--------------------------------------?????????----------------------------------------------------------------*/
void PID_Struct_Init(_pid *pid,float p, float i, float d,unsigned char param1,unsigned char param2,unsigned char param3)
{
    pid->target_val=0;				
		pid->actual_val=0;
    pid->err=0;
    pid->err_last=0;
    pid->err_pre=0;
    pid->integral=0;
		pid->out = 0;

    pid->Kp = p;    // ?????????? P
		pid->Ki = i;    // ?????????? I
		pid->Kd = d;    // ?????????? D
    pid->param1 = param1; // ??????
    pid->param2 = param2; // ¦Ë??? or ??????
    pid->param3 = param3; // ???????????  
}

void PID_param_init()
{
	PID_Struct_Init(&pid_angle,Incremental_KP_A,Incremental_KI_A,Incremental_KD_A,PIDparam1_An,PIDparam2_I,PIDparam3_finish);
	pid_angle.param5 = PIDparam5_Local_Control;
   /***********???1 PID????**********************/
	/* ¦Ë????????????? */
	PID_Struct_Init(&pid_location,Position_KP,Position_KI,Position_KD,PIDparam1_M2_Left,PIDparam2_L,PIDparam3_finish);
	/* ?????????????? */
	PID_Struct_Init(&pid_speed,Incremental_KP,Incremental_KI,Incremental_KD,PIDparam1_M2_Left,PIDparam2_I,PIDparam3_finish);

	/***********???2 PID????**********************/
	/* ¦Ë????????????? */
	PID_Struct_Init(&pid_location2,Position_KP,Position_KI,Position_KD,PIDparam1_M1_Right,PIDparam2_L,PIDparam3_finish);
	/* ?????????????? */
	PID_Struct_Init(&pid_speed2,Incremental_KP2,Incremental_KI2,Incremental_KD2,PIDparam1_M1_Right,PIDparam2_I,PIDparam3_finish);
}

// void set_pid_target(_pid *pid, float temp_val)
// {
//   pid->target_val = temp_val;    // ????????????
// }

// float get_pid_target(_pid *pid)
// {
//   return pid->target_val;    // ????????????
// }

// void set_p_i_d(_pid *pid, float p, float i, float d)
// {
//   	pid->Kp = p;    // ?????????? P
// 		pid->Ki = i;    // ?????????? I
// 		pid->Kd = d;    // ?????????? D
// }







 






